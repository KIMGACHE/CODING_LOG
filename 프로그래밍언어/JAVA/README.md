## JAVA

**프로그래밍 언어** <br>
pro(앞으로,미리)gram(쓰다): 앞으로 할 일을 미리 적어놓는 작업 <br>

사람(자연어) -> 컴퓨터(기계어) <br>
사람(자연어) -> Compiler -> 컴퓨터(기계어) <br>

자바JAVA = C언어(절차지향문법) + C++(객체지향문법) <br>
클래스 영역 - 객체지향 문법 적용단위 <br>
메서드 영역 - 절차지향 문법 적용 단위 <br>
메서드(함수) : 작업수행을 하는데 필요한 여러 코드를 묶어서 실행하는 단위 <br>
main 메서드 : 최초 실행 함수 <br>
library 메서드 : 미리 만들어져 제공되어지는 메서드 <br>
사용자 정의 메서드 : 개발자에 의해 만들어지는 메서드 <br>

함수(data) : 수를 담아 특정 처리를 하는 논리적 공간 <br>

### 기본입출력
System : OS <br>
System.out : OS가 관리하는 표준 출력 스트림 <br>
		
System.out.print(); : 기본 출력 <br>

**ESCAPE문자**  <br>
\n : 개행, 줄바꿈 <br>
\b : 백스페이스 <br>
\t : 탭길이(기본 8칸) 만큼 커서 이동 <br>
특수문자를 입력하고 싶을 때 /을 사용한다. : ex) "" <br>

```
System.out.print("Hi\n"); // "Hi"이후에 줄바꿈이 일어난다.
System.out.print("Hi\b"); // "Hi"이후 해당 위치에서 한 문자를 지운다.
System.out.print("Hi\t"); // "Hi"이후 탭길이 만큼 공백을 생성한다.
System.out.println("I SAY \"HELLO\""); // ""를 문자로 출력가능하다.
```

**서식 문자** <br>
printf(); 를 사용해야한다. <br>
%d : 정수 서식문자 <br>
%f : 실수 서식문자 <br>
%c : 문자 서식문자 <br>
%s : 문자열 서식문자 <br>
%o : 8진수 서식문자 <br>
%x : 16진수 서식문자 <br>

자동 줄바꿈 System.out.println();

### 음수표현
컴퓨터(CPU)는 가산회로에 의해 덧셈처리를 할 수가 있다. <br>
컴퓨터(CPU)는 뺄셈처리는 할 수 없다. <br>
그런데 실제로 뺄셈의 결과를 가져오는 이유는 보수개념을 도입했기 때문이다. <br>

1. 1의 보수 (-127 ~ +127)
   - 2진수로 표현된 수에 역을 취한다. ex) 00001111(15) -> 11110000(-15)
3. 2의 보수 (-128 ~ +127)
   - 2진수로 표현된 수에 역을 취한다음 +1 시킨다. ex) 00001111(15) -> 11110001(-15)

<br>

### 자료형
수(Data) : 선 저장 / 후 처리 <br>
변수 : 개발자의 유지보수 측면에서 바뀔 가능성이 있는 수 <br>
변수명 : 저장되어져 있는 변수 공간에 접근하기 위한 문자형태의 주소 <br>
자료형 : 수(Data)를 저장하고 데이터의 유형을 제한하기 위해 사용되는 예약어 <br>

```
int n1 = 10; // 리터럴 상수값 10을 상수Pool공간에 저장한 다음에 4byte(int형)공간을 생성 -> n1이름 부여 -> 10대입(초기화)
int n2 = 4; // 리터럴 상수값 4을 상수Pool공간에 저장한 다음에 4byte(int형)공간을 생성 -> n2이름 부여 -> 4대입(초기화)
int n3 = n1 + n2; // n1안의 값과 n2안의 값의 덧셈결과를 4byte공간 생성 -> n3이름부여 -> 14대입(초기화)
```
<br>

**원시타입 자료형**
byte	1byte	8bit -> -128~+127 <br>
short	2byte	16bit -> -32768~+32767 <br>
char	2byte	16bit -> 0~65535 <br>
int	4byte	32bit -> +-21억 <br>
long	8byte	64bit -> 많다 <br>
float	4byte	32bit -> 지수.가수부 <br>
long	8byte	64bit -> 지수.가수부 <br>

**실수** <br>
유리수와 무리수의 통칭 <br>
소숫점이하값을 가지는 수 123.456 <br>
float : 4byte 실수 (6-9자리) <br>
double : 8byte 실수 (15-18자리), 기본자료형 <br>
f,F : float형 접미사 <br>

```
//---------------------------------------
//정수 int - 4byte 정수 부호 o
//---------------------------------------
int n1 = 0b10101101;	//2진수
int n2 = 173;			//10진수 정수값
int n3 = 0255;			//8진수
int n4 = 0xad;			//16진수
System.out.printf("%d %d %d %d\n",n1,n2,n3,n4);
		
//---------------------------------------
//정수 byte - 1byte 정수 부호 o
//---------------------------------------
byte n5 = (byte)-129;
byte n6 = -30;
byte n7 = 30;
byte n8 = 127;
byte n9 = 129; // byte는 양수를 127까지밖에 표현하지 못하기 때문
System.out.printf("%d\n",n5);
System.out.println(0b10101101); // 기본형이 int라 양수표시
System.out.println(Integer.toBinaryString(-129));
		
//---------------------------------------
//정수 short - 2byte 정수 부호 o | char-2byte정수 부호x(양수만)
//---------------------------------------
char n1 = 65535; // (0~2^16-1) (0~65535)
short n2 = 32767; // (-2^15 ~ +2^15-1)(-32768~+32767)

char n3 = 60000;
short n4 = n3; // 문제발생

System.out.printf("%d\n",n4);
		
		
//---------------------------------------
//정수 long-8byte 정수 부호o
//---------------------------------------
long n1 = 10;
long n2 = 20; // L,l (리터럴접미사) : long 자료형 사용하여 값 저장
		
long n3 = 10000000000; // 백억, 문제발생
long n4 = 10000000000L; // 미리붙여서 long자료형을 사용하겠다는 표시

```
<br>

**단일문자 char 2byte** <br>
char는 문자로 출력도 되고 숫자로도 출력이 된다. <br>
```
char ch1 = 'a';
System.out.println(ch1); -> a
System.out.println((int)ch1); -> 97
System.out.println('b'+1); -> c

System.out.printf("%c \n",0xac00); -> 가
System.out.printf("%c \n",'\uac00'); -> 가 // 역슬래쉬u : 뒤에 나오는 문자가 유니코드 문자임을 나타냄
```

### (자료형)형변환
연산작업시 (=,+,-) 일치하지 않는 자료형을 일치시키는 작업을 형변환이라고 한다. <br>
자동형변환(암시적형변환) : 컴파일러에 의해 자동으로 변환 <br>
강제형변환(명시적형변환) : 프로그래머에 의해 강제로 변환 <br>
<br>
자동형변환인 경우 데이터 손실을 최소화하는 방향으로 자료형을 일치시킨다. <br>
byte < short, char < int < long < float < double <br>
그래서 좁은 범위의 자료형에서 큰 범위의 자료형으로 대입연산자를 사용하면 대부분 자연스럽게 형변환된다. <br>
<br>
강제형변환의 경우 좁은 범위의 공간에 큰 범위의 값을 넣으려고 하는 경우에 사용한다. <br>
데이터 손실 우려가 있기 때문에 컴파일 수준에서 에러를 확인할 수 있다. <br>
이때 해당 오류를 무시하고 강제로 변환하는 작업을 강제 형변환이라고 한다. <br>
```
byte x = 10;
byte y = 20;
byte result1 = x + y; // error! int보다 작은 변수자료형(정수)이 연산을 하면 int로 처리하여 계산을 하기 때문에
byte result2 = (byte)(x+y); // 강제 형변환이 없으면 에러가 발생한다.

byte var1 = 10;
int var2 = 100;
long var3 = 1000L;
long result = var1 + var2 + var3; // int보다 큰 자료형이 있으면 연산의 결과가 큰 자료형으로 바뀐다.
```
<br>
실수 타입은 큰 타입으로 자동 형변환 <br>

### 표준 입출력
```
Scanner sc = new Scanner(System.in);
```
System.out : 운영체제가 관리하고 있는 자원들 중에 표준 출력 스트림<br>
System.in : 운영체제가 관리하고 있는 자원들 중에 표준 입력 스트림<br>
스트림 : 데이터의 전송흐름, 단방향<br>
<br>
new Scanner(System.in) <br>
표준 입력장치(키보드)로부터 전달되는 데이터를 받을 수 있는 Scanner객체를 생성<br>
Scanner sc = new Scanner(System.in) <br>
Scanner객체를 main함수내에서 제어(접근,사용)할 수 있도록 sc변수에 위치정보를 저장<br>
<br>

**스캐너 변수** <br>
.next() : 문자열 입력받는 함수, 띄어쓰기는 포함하지 않는다. <br>
.nextInt() : 정수를 입력받는 함수 <br>
.nextLine() : 문자열 입력받는 함수, 띄어쓰기도 포함하고 줄바꿈에 의해 종료된다. <br>
.nextDouble() : 실수를 입력받는 함수 <br>

### 연산자
1. 기본 산술 연산자 : +, -, *, /, %(나머지연산)
2. 복합 대입 연산자(산술 + 대입)
   - a = a + 1을 a+=1로 줄여서 사용 가능하다.
   - b = b - 1을 b-=1로 줄여서 사용 가능하다.
   - c = c * 2를 c*=2로 줄여서 사용 가능하다.
   - 나누기와 나머지 연산자도 가능하다.
4. 비교 연산자 : <, >, <=, >=, ==, !=
5. 논리 연산자
   - && : AND연산자, 해당 연산자의 양옆의 조건이 다 참이어야만 참을 반환한다. 첫번째 조건식이 거짓일 경우 뒤의 조건식은 실행하지 않는다.
   - || : OR연산자, 해당 연산자의 양옆의 조건 중 하나라도 참이면 참을 반환한다. 첫번째 조건식이 참일 경우 뒤의 조건식은 실행하지 않는다.
   - ! : NOT연산자, true를 false로 false를 true로 바꾸어 반환한다.
9. 증감 연산자
    - ++a(--a) : 전치연산자, 먼저 값을 1증가(감소)시킨 뒤 다른 연산자를 처리한다.
    - a++(a--) : 후치연산자, 다른 연산자를 처리한 뒤 값을 1증가(감소)한다.
11. 삼항 연산자
    - (조건식) ? 참인경우의 실행코드 : 거짓인 경우 실행코드
    - ex) char grade = (score > 90) ? 'A' : 'B';

### Bit연산자
1. AND(&) : 두 비트가 모두 1이면 1을 반환한다.
2. OR(|) : 두 비트 중 하나라도 1이면 1을 반환한다.
3. XOR(^) : 두 비트 중 1의 개수가 홀수이면 1을, 짝수이면 0을 반환한다.
4. NOT(~) : 0을 1로 1을 0으로 반환한다.

### Shift연산자
1. << : 모든 Bit를 왼쪽으로 N칸 민다. 10진수 기준으로 1칸 밀 때마다 x2가 된다.
2. >> : 모든 Bit를 오른쪽으로 N칸 민다. 10진수 기준으로 1칸 밀 때마다 /2가 된다.

ex) int num 3 = 15 << 3; -> 120

### 조건문
**IF문** <br>
if(조건식) <br>
{ <br>
참인 경우 실행되는 종속문장 <br>
} <br>
```
if (age >=8) {
   System.out.println("학교에 다닙니다.");
}
if(age < 8) {
   System.out.println("학교에 다니지 않습니다.");
}
```
<br>

**IF-ELSE문** <br>
if(조건식) { <br>
   참인 경우 실행되는 종속문장 <br>
} else { <br>
   거짓인 경우 실행되는 종속문장 <br>
} <br>

```
if (age >=8) {
   System.out.println("학교에 다닙니다.");
} else {
   System.out.println("학교에 다니지 않습니다.");
}
```

<br>

**switch문** <br>
switch(조건식에 사용할 변수) {
   case 조건에 사용될 변수의 값:
   	조건이 참일때 실행코드;
    	break;
   case 조건에 사용될 변수의 값:
   	조건이 참일때 실행코드;
    	break;
   case 조건에 사용될 변수의 값:
   	조건이 참일때 실행코드;
    	break;
   default :
   	모든 조건이 거짓일 때 실행코드;
}
<br>

```
int ranking = 2;
char medalColor;
switch(ranking) {
   case 1:
	medalColor='G';
	break;
   case 2:
	medalColor='S';
	break;
   default:
	medalColor='C';
}
```
<br>

**WHILE문**
while(조건식) { <br>
   조건식이 참인 경우 실행되는 종속 문장(1개의 행일 때는 생략가능) <br>
} <br>
<br>
while문을 사용하려면 **탈출용 변수**, **탈출을 위한 조건식**, **탈출을 위한 연산식**이 필요하다.
<br>

```
int count = 0; // 탈출용 변수
while(count<5) { // 탈출을 위한 조건식
   System.out.println("HELLO WORLD");
   count++; // 탈출을 위한 연산식
}
```

## 객체
**객체** - Object, 존재(배타적,독립적인 공간을 차지)하는 사물 <br>
객체 구조 <br>
 - 속성(Attribute) : 객체만의 고유한 Data -> (멤버)변수를 통해 저장 <br>
 - 기능(Function) : 객체가 수행할 수 있는 Action -> (멤버)함수를 통해 구현 <br>
 <br>
객체 지향 - 현실 객체의 정보(속성/기능)중에 필요한 일부만 추출(추상화)하여 프로그램에 적재하기 위해 고안된 문법체계<br>
<br>
**Class** <br>
동일한 종류의 객체에 필요한 메모리 공간을 제공하기 위해 선언된 자료형 <br>
클래스는 선언하기 전에는 기본적으로 메모리 공간을 차지하지 않는다. <br>
클래스 자료형에 의해 객체가 정의 되는 순간 클래스에서 선언한 속성과 기능대로 공간이 형성되어진다. <br>
단일 클래스내에 public클래스가 여러개 존재할 수 없다.<br>
같은 패키지내에 같은 클래스명을 가진 클래스가 존재할 수 없다.

### 자바의 메모리 영역
1. 스택영역 : {}내에서 생성되는 공간 (int,double...)
2. 클래스(메서드)영역 : 공유메모리 영역(생성자,일반매서드,**static매서드**,**static변수**)
3. 힙(heap)영역 : 객체 저장 영역(new 예약어 사용시 할당)
```
// 코드 해석
Scanner sc = new Scanner(System.in);
// new : 힙영역에 객체를 저장하는데 사용하는 예약어
// Scanner() : 객체에 필요한 초기값을 부여하기 위한 생성자 매서드
// Scanner sc : Scanner라는 클래스 자료형으로 정의된 참조변수 sc

// 힙 영역에 Scanner객체를 생성한 뒤 객체의 주소를 sc 이름의 참조변수에 저장.
```

### 생성자 매서드
객체 생성시 필요한 메모리공간 형성과 초기값 부여에 사용되는 매서드<br>
객체 생성시 한번 호출되는 매서드로 재사용이 불가하다.<br>
생성자 매서드의 이름은 클래스의 이름과 동일하게 작성하되 반환자료형은 작성하지 않는다.<br>
생성자 매서드를 클래스 내에 작성하지 않으면 컴파일러에 의해 주입되는 생성자(디폴트 생성자)가 자동 설정된다.<br>
디폴트 생성자는 모든 멤버변수의 초기값을 0 or false or null 로 지정한다.<br>
**클래스 선언시 생성자함수를 1개 이상 명시하게 되면 디폴트 생성자가 자동주입되지 않으니 주의!** <br>

### 변수 종류
멤버 변수 : 클래스 내의 멤버로 사용되는 변수 ( 속성 저장 ) <br>
지역 변수 : {}내에서 선언되는 변수, {}를 벗어난다면 공간 반환, 변수명 중복시 좁은 지역의 변수가 적용
전역 변수 : static 변수

### 매서드 오버로딩
매서드 이름은 동일하지만 파라미터가 다른 여러 매서드를 만드는 것을 말한다.<br>
조건<br>
1. 매서드 이름이 같아야 한다.
2. 파라미터의 개수 또는 자료형이 달라져야 한다.
3. 파라미터는 같고 리턴 변수의 자료형이 달라지면 안된다.
<br>
```
int sum(int x, int y) {
   System.out.println("int sum(int x, int y)");
return x+y;
int sum(int x, int y, int z) {
   System.out.println("int sum(int x, int y, int z)");
return x+y+z;
int sum(double x, double y, double z) {
   System.out.println("int sum(double x, double y, double z)");
return (int)(x+y+z);
}
```

## 정보은닉과 캡슐화
**정보 은닉** : 정보를 숨기는 것 <br>
왜 사용할까? 민감한 데이터에 접근할 수 없도록 하기 위해 <br>
<br>
**접근 한정자**
**public**: 모든 클래스에서 접근이 가능하다.<br>
**protected**: 동일 패키지에 속한 클래스 및 서브 클래스에서 접근이 가능하다.<br>
**default**: 동일 패키지에 속한 클래스에서만 접근을 허용한다. 한정자를 사용하지 않았을 때의 기본값이다.<br>
**private**: 현재 클래스에서만 접근이 가능하다.<br>
<br>
**캡슐화**<br>
캡슐화 : 생성한 객체를 어떤 매서드와 어떤 필드로 어떻게 일을 수행할 지 외부에 숨기는 것.<br>
**특정 목적을 가지는 기능 구현에 있어서 각 과정의 일부나 전부가 외부로 노출되는 문제를 막기 위해 정보은닉을 수반한다.** <br>
정보은닉을 할 수도 있고 필요치 않으면 노출시킬 수도 있다.(필수는 아니다.)<br>

### this
1. 멤버변수, 매개변수를 구별하는데 사용한다.
2. 다른 생성자를 호출하는데 사용한다.
```
thisMain(int x, int y) {this.x = x; this.y = y;}
thisMain(int x) {this(x,0);} // 첫번째 생성자를 호출
thisMain() {this(0,0);} // 첫번째 생성자를 호출
```
<br>

### 원시타입 배열
원시타입[] 배열명 = new 원시타입[사이즈]; <br>

### 얕은복사 / 깊은복사
1. 얕은복사(주소복사)
   ```
   int arr1[] = {10,20,30};
   int arr2[];
   arr2 = arr1;
   // arr1의 값이 변경되면 arr2의 값도 변경된다. 서로 같은 메모리 주소를 사용하기 때문.
   ```
3. 깊은복사(값복사)
   ```
   int arr3[] = new int[3];
   for(int i=0; i<arr3.length;i++){
	arr3[i] = arr1[1];
   }
   // arr3에 arr1의 값을 복사한다. arr1의 값이 변경된다고 arr3의 값이 변경되지는 않는다.
   ```
### 클래스타입 배열
```
class classArr {
   String name;
   int age;

   classArr() {
      super();
      this.name=name; this.age=age;
   }
}

public class C04클래스타입배열 {
   public static void main(String[] args) {
      classArr list[] = new classArr[3]; // classArr클래스타입의 배열을 선언
      list[0] = new classArr(); // 이때 생성자를 통해 객체를 생성하지 않고 아래의 변수를 설정하게 되면 에러가 발생한다.
      list[0].name = "홍길동"; // 객체를 생성하지 않으면 각 배열의 인덱스에는 class타입의 기본값인 null이 들어가게되고
      list[0].age = 55; // null.멤버변수에 접근 할 수 없기 때문이다.
   }
}
```

### static
static : 클래스 매서드와 클래스 변수를 선언하는데 사용한다.<br>
static은 자바의 정적 영역에 할당되는 리소스를 선언하는데 사용하며 동일 가상머신상에서 실행중인 모든 클래스에서 공유한다.<br>
객체를 생성하지 않고도 클래스의 매서드나 멤버에 접근할 수있다. <br>

**static변수를 이용한 SingletonPattern** <br>
어떤 클래스의 객체를 단 하나만 생성하고 해당 객체를 공유하여 사용하는 방식 <br>
```
class Company {
	int n1;
	int n2;
	
	private static Company instance; // instance라는 멤버변수, static
	private Company() {} // 외부에서 Company 객체를 생성하지 못하게 막는다.
	public static Company getInstance() {
		if(instance==null)
			instance = new Company(); // 객체를 아무도 만들지 않았을 때 객체생성
		return instance; // 객체가 이미 존재한다면 존재하는 객체 리턴
	}
}
```

## 상속
상속은 클래스를 추상화하거나 구체화하는 과정에서 발생한다. <br>
상속을 이용하면 상위클래스(슈퍼클래스)의 기본 구성요소(필드, 메서드)를 물려받으며, 자신만의 필드나 메서드를 추가할 수 있다. <br>
물려받은 메서드의 내용을 수정하는 것도 가능하다. (overriding) <br>
<br>

**상속을 사용하는 이유**
1. 코드 중복방지(가독성)
2. 유지보수 용이
3. 확장성
<br>

**매서드 오버라이딩** <br>
상속관계를 전제로 상위클래스의 매서드를 하위클래스가 재정의하는 것을 허용한 문법<br>
매서드의 헤더부분은 통일하게 두고 본체({})의 로직을 다양하게 둠으로써(다형성) 같은 함수를 상위클래스로부터 물려받더라도 각 하위클래스마다 다양한 형태의 결과물을 만들어 낼 수 있다.<br>
<br>

**오버로딩 vs 오버라이딩** <br>
오버로딩 : 헤더를 건드린다, 개발자의 편의성에 중점(함수 이름 단일화), 상속을 전제로 하지않는다.<br>
오버라이딩 : 본체(body)를 건드린다, 다형성, 상속을 전제로 한다.<br>
<br>

**Up&Down Casting** <br>
1. UpCast(자동 형변환)
   부모 클래스형의 참조변수 = 자식 클래스의 객체<br>
   부모 클래스형의 참조변수를 통하여 부모 클래스의 속성에만 접근할 수 있다.<br>
   (자식클래스의 메모리 영역이 더 크므로 메모리 영역이 더 작은 부모 클래스 자료형은 자식클래스 객체가 부모로부터 물려받은 곳에만 접근할 수 있기 때문이다. 또한 그게 메모리 영역에 모순이 없으므로 자동적으로 형변환된다.)<br>
3. DownCast(강제 형변환)
   하위클래스형의 참조변수 = 상위 클래스의 객체<br>
   UpCasting을 전제로 확장된(추가된)멤버에 접근하기 위해 사용<br>
   (위에서 적었듯 자식클래스의 메모리 영역이 더 크므로 자식클래스의 자료형이 부모클래스의 객체에 접근하게 되면 엉뚱한 메모리에 접근할 수 있기 때문에 치명적인 문제를 야기할 수 있다. 따라서 UpCasting을 전제로 사용하여야 한다.)<br>

<br>

**클래스의 매서드** <br>
클래스의 매서드는 공유 메모리 공간에 적재된다. 단 객체 생성유무와 관계없이 적재되는 static과 달리 객체 생성시에 적재된다. <br>
UpCasting을 하면 상속관계의 모든 클래스로 만든 객체를 연결할 수 있다. <br>
UpCasting상태에서는 확장된 멤버변수 접근이 불가능하다. -> DownCasting으로 해결가능하다. <br>
UpCasting상태에서는 재정의된 함수에 접근이 가능하다.(UpCasting을 사용하는 이유) <br>
<br>
재정의된 함수에 접근이 가능한 이유 : 상위클래스에 func1이라는 매서드가 있고 하위 클래스에서 func1이라는 매서드를 오버라이딩했을 때(재정의), UpCasting을 하여 하위클래스가 상속받은 부분에만 접근할 수 있다. 이 때 func1은 상속한 매서드이면서 재정의된 함수로 공유 메모리영역에 있기때문에 하위클래스의 재정의된 함수에 접근이 되는 것이다. <br>

## 추상클래스
추상 매서드(정의되지 않고 선언만 한 매서드)를 하나 이상 포함해야한다. <br>
추상 매서드가 포함된 클래스는 반드시 추상클래스(abstract)로 정의해야 한다.(자식 클래스에서 매서드 정의) <br>
추상 클래스는 일반 클래스와 같이 멤버 변수 및 일반 매서드를 포함할 수 있다. <br>
추상 클래스는 객체를 생성할 수 없다. 반드시 추상 클래스를 상속받는 클래스를 만든 후 추상 클래스에서 선언된 모든 추상 매서드를 재정의하여 일반 매서드로 완성한 다음 객체를 생성해야 한다. <br>

<br>

**사용하는 이유** : 프로그램을 구체적으로 어떻게 구현할지 결정이 되지 않았거나, 프로그램을 동일한 규격으로 만들 수 있도록 가이드를 제공 <br>







